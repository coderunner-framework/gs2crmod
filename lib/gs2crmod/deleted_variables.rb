{:norm_option=>
  {:help=>
    "The definition of <math>v_{th}</math>\n** 'with_root_2', 'default', and  'mtk' are equivalent ways of choosing v_t = sqrt(2T/m)</I>.\n** 'no_root_2', 'bd',  and  't_over_m' are equivalent ways of choosing v_t = sqrt(T/m).  Recommended \n\n\n <big>Note: In the input file, only one of the following sections need to be included, depending on the value of [[grid_option]].</big>",
   :should_include=>"true",
   :description=>"The definition of v_th",
   :tests=>["Tst::STRING"],
   :autoscanned_defaults=>["default"],
   :must_pass=>
    [{:test=>"kind_of? String",
      :explanation=>"This variable must be a string."}],
   :type=>:String,
   :text_options=>
    ["default", "with_root_2", "mtk", "no_root_2", "bd", "t_over_m"]},
 :vmom_eq=>
  {:help=>" Use VMOMS equilibrium (VMOMS, old TRANSP)\n",
   :should_include=>"true",
   :description=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :ismooth=>
  {:should_include=>"true",
   :description=>nil,
   :help=>
    " \n** 0:  Recommended \n** 1: Artificially smooth metric coefficients\n",
   :tests=>["Tst::INT"],
   :gs2_name=>:ismooth,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[0],
   :type=>:Integer,
   :code_name=>:ismooth},
 :ak0=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Smoothing parameter.  Rarely used.\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:ak0,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[1.0],
   :type=>:Float,
   :code_name=>:ak0},
 :k1=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Smoothing parameter.  Rarely used.\n",
   :tests=>["Tst::INT"],
   :gs2_name=>:k1,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[-30],
   :type=>:Integer,
   :code_name=>:k1},
 :k2=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Smoothing parameter.  Rarely used.\n",
   :tests=>["Tst::INT"],
   :gs2_name=>:k2,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[-15],
   :type=>:Integer,
   :code_name=>:k2},
 :advanced_egrid=>
  {:help=>
    " T: Use Candy-Waltz energy grid   Recommended \n** F: Use Kotschenreuther energy grid\n",
   :should_include=>"true",
   :description=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :vgrid=>
  {:help=>nil,
   :should_include=>"true",
   :description=>nil,
   :tests=>["Tst::STRING"],
   :autoscanned_defaults=>[],
   :must_pass=>
    [{:test=>"kind_of? String",
      :explanation=>"This variable must be a string."}],
   :type=>:String},
 :testfac=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::INT"],
   :gs2_name=>:testfac,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[],
   :type=>:Integer,
   :code_name=>:testfac},
 :ecut=>
  {:help=>
    " If advanced_egrid=T: Maximum energy resolved\n** Otherwise: Break between discretizations of energy grid.\n",
   :should_include=>"true",
   :description=>nil,
   :tests=>["Tst::FLOAT"],
   :autoscanned_defaults=>[],
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float},
 :nperiod_guard=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Obsolete\n",
   :tests=>["Tst::INT"],
   :gs2_name=>:nperiod_guard,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[0],
   :type=>:Integer,
   :code_name=>:nperiod_guard},
 :save_n=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Used only for debugging.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:save_n,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".true."],
   :type=>:Fortran_Bool,
   :code_name=>:save_n},
 :noise=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Used only for debugging.  noise < 0  turns off this feature. \n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:noise,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[-1.0],
   :type=>:Float,
   :code_name=>:noise},
 :kill_grid=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:kill_grid,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:kill_grid},
 :h_kill=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:h_kill,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".true."],
   :type=>:Fortran_Bool,
   :code_name=>:h_kill},
 :neoflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:neoflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:neoflux},
 :g_pvg=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :code_name=>:g_pvg,
   :must_pass=>
    [{:test=>"kind_of? Numeric",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float},
 :d_kill=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Experimental.  D_kill < 0 turns off this feature.\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:D_kill,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[-10.0],
   :type=>:Float,
   :code_name=>:D_kill},
 :vncoef=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Parameter in Krook operator.  \n",
   :tests=>["Tst::FLOAT"],
   :code_name=>:vncoef,
   :must_pass=>
    [{:test=>"kind_of? Numeric",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float},
 :absom=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  Parameter in Krook operator.  \n",
   :tests=>["Tst::FLOAT"],
   :code_name=>:absom,
   :must_pass=>
    [{:test=>"kind_of? Numeric",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float},
 :ivnew=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Parameter in Krook operator.  \n",
   :tests=>["Tst::INT"],
   :code_name=>:ivnew,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :type=>:Integer},
 :conserve_number=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Applicable only for Krook operator\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :code_name=>:conserve_number,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :type=>:Fortran_Bool},
 :conserve_momentum=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Conserve parallel momentum.  Recommend F at this time.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :code_name=>:conserve_momentum,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :type=>:Fortran_Bool},
 :k0=>
  {:should_include=>"true",
   :description=>"Advanced. Rarely used.",
   :help=>
    "Available for highly specialized initial conditions.  Do not use unless you know what you are doing. Rarely used.",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:k0,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[1.0],
   :type=>:Float,
   :code_name=>:k0},
 :write_phi=>
  {:help=>"No longer used.",
   :should_include=>"true",
   :description=>"No longer used.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".true."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_qheat=>
  {:help=>"No longer used.",
   :should_include=>"true",
   :description=>"No longer used.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_dmix=>
  {:help=>"If (write_ascii = T) write D_ML to output file.",
   :should_include=>"true",
   :description=>"If (write_ascii = T) write D_ML to output file.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_stress=>
  {:help=>
    "Klaus Hallacek's diagnostic for toroidal stress... see his (unpublished) paper",
   :should_include=>"true",
   :description=>
    "Klaus Hallacek's diagnostic for toroidal stress... see his (unpublished) paper",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_lamavg=>
  {:help=>
    "Time averaged turbulent fluxes as a function of lambda (= mu/E). Write particle flux vs. pitch angle (lambda) to runname.lam and energy flux vs. lambda to runname.lame",
   :should_include=>"true",
   :description=>
    "Time averaged turbulent fluxes as a function of lambda (= mu/E).",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_tavg=>
  {:help=>
    "Write time averaged turbulent fluxes as a function of theta. Write particle flux vs. theta to runname.theta and energy flux vs. theta to runname.thetae",
   :should_include=>"true",
   :description=>
    "Write time averaged turbulent fluxes as a function of theta.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_eavg=>
  {:help=>
    "Time averaged turbulent fluxes as a function of energy (E). Write particle flux vs. energy to runname.energy and energy flux vs. energy to runname.energye",
   :should_include=>"true",
   :description=>"Time averaged turbulent fluxes as a function of energy (E).",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_apar=>
  {:help=>"Deprecated",
   :should_include=>"true",
   :description=>"Deprecated",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".true."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_aperp=>
  {:help=>"Deprecated",
   :should_include=>"true",
   :description=>"Deprecated",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".true."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :test_conserve=>
  {:help=>
    "Plots zonal flow component (ie. ky=0,kz=0) of moments of h vs time into NetCDF file",
   :should_include=>"true",
   :description=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :print_old_units=>
  {:help=>
    "Deprecated. If false print internal code units.  If true requencies on screen in (1/omega_* units, omega_*=(cT/eB)*ky/L_ref.)",
   :should_include=>"true",
   :description=>"Deprecated.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_fieldline_avg_phi=>
  {:help=>"Ignored",
   :should_include=>"true",
   :description=>"Ignored",
   :tests=>["Tst::FORTRAN_BOOL"],
   :autoscanned_defaults=>[".false."],
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a Fortran boolean. (In Ruby this is represented as a string: e.g. '.true.') "}],
   :type=>:Fortran_Bool},
 :write_bpar=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_bpar,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".true."],
   :type=>:Fortran_Bool,
   :code_name=>:write_bpar},
 :write_pflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_pflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_pflux},
 :write_vflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_vflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_vflux},
 :write_qmheat=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_qmheat,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_qmheat},
 :write_pmflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_pmflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_pmflux},
 :write_vmflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_vmflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_vmflux},
 :write_qbheat=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_qbheat,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_qbheat},
 :write_pbflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_pbflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_pbflux},
 :write_vbflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  No longer used.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_vbflux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[],
   :type=>:Fortran_Bool,
   :code_name=>:write_vbflux},
 :write_kperpnorm=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_kperpnorm,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_kperpnorm},
 :write_phitot=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_phitot,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".true."],
   :type=>:Fortran_Bool,
   :code_name=>:write_phitot},
 :write_epartot=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_epartot,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_epartot},
 :write_fcheck=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Obscure\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_fcheck,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_fcheck},
 :write_vortcheck=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  Obscure\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_vortcheck,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_vortcheck},
 :write_fieldcheck=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  Obscure\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_fieldcheck,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_fieldcheck},
 :write_neoclassical_flux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>
    "  Turns on neoclassical flux calculation but result is not written.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_neoclassical_flux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_neoclassical_flux},
 :dump_neoclassical_flux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Neoclassical fluxes written to dump.neoflux\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:dump_neoclassical_flux,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:dump_neoclassical_flux},
 :dump_final_xfields=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" No longer maintained.\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:dump_final_xfields,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:dump_final_xfields},
 :use_shmem_for_xfields=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Obsolete\n",
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:use_shmem_for_xfields,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".true."],
   :type=>:Fortran_Bool,
   :code_name=>:use_shmem_for_xfields},
 :nperiod_output=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Obsolete\n",
   :tests=>["Tst::INT"],
   :gs2_name=>:nperiod_output,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>["min(nperiod,nperiod_output)"],
   :type=>:Integer,
   :code_name=>:nperiod_output},
 :write_epolar=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FORTRAN_BOOL"],
   :gs2_name=>:write_Epolar,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :autoscanned_defaults=>[".false."],
   :type=>:Fortran_Bool,
   :code_name=>:write_Epolar},
 :real=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :code_name=>:real,
   :must_pass=>
    [{:test=>"kind_of? Numeric",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float},
 :public=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::INT"],
   :code_name=>:public,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :type=>:Integer},
 :thetas=>
  {:should_include=>"true",
   :description=>nil,
   :help=>"  ?\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:thetas,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[1.0],
   :type=>:Float,
   :code_name=>:thetas},
 :a_ext=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored.\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:a_ext,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.0],
   :type=>:Float,
   :code_name=>:a_ext},
 :aky_star=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored.\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:aky_star,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.0],
   :type=>:Float,
   :code_name=>:aky_star},
 :akx_star=>
  {:should_include=>"true",
   :description=>nil,
   :help=>" Ignored.\n",
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:akx_star,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.0],
   :type=>:Float,
   :code_name=>:akx_star},
 :ntheta0=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::INT"],
   :gs2_name=>:ntheta0,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[0, 1],
   :type=>:Integer,
   :code_name=>:ntheta0},
 :lx=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:lx,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[1.0],
   :type=>:Float,
   :code_name=>:lx},
 :aky=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:aky,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.2, 0.4],
   :type=>:Float,
   :code_name=>:aky},
 :nx=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::INT"],
   :gs2_name=>:nx,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[0],
   :type=>:Integer,
   :code_name=>:nx},
 :nflux=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::INT"],
   :gs2_name=>:nflux,
   :must_pass=>
    [{:test=>"kind_of? Integer",
      :explanation=>"This variable must be an integer."}],
   :autoscanned_defaults=>[50],
   :type=>:Integer,
   :code_name=>:nflux},
 :flux_option=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::STRING"],
   :gs2_name=>:flux_option,
   :must_pass=>
    [{:test=>"kind_of? String",
      :explanation=>"This variable must be a string."}],
   :autoscanned_defaults=>["default"],
   :type=>:String,
   :text_options=>["default", "adjust"],
   :code_name=>:flux_option},
 :delta=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:delta,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.1],
   :type=>:Float,
   :code_name=>:delta},
 :flux_eps=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:eps,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[0.3, 0.5],
   :type=>:Float,
   :code_name=>:eps},
 :heat=>
  {:should_include=>"true",
   :description=>nil,
   :help=>nil,
   :tests=>["Tst::FLOAT"],
   :gs2_name=>:heat,
   :must_pass=>
    [{:test=>"kind_of? Float or kind_of? Integer",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :autoscanned_defaults=>[50.0],
   :type=>:Float,
   :code_name=>:heat},
 :include_lowflow=>
  {:should_include=>"true",
   :description=>"Include low flow terms in the gyrokinetic equation.",
   :help=>
    "Include calculation of terms present in the low flow limit of gyrokinetics. Many new terms... will slow calculation... don't set true unless you know what you are doing.",
   :tests=>["Tst::FORTRAN_BOOL"],
   :code_name=>:include_lowflow,
   :must_pass=>
    [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
      :explanation=>
       "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
   :type=>:Fortran_Bool,
   :module=>:dist_fn},
 :rhostar=>
  {:should_include=>"true",
   :description=>"Normalised gyro-radius.",
   :help=>
    "Normalised gyro-radius, <math>\\frac{\\rho}{a}</math>, needed for calculating the momentum flux in the low flow limit.",
   :tests=>["Tst::FLOAT"],
   :code_name=>:rhostar,
   :must_pass=>
    [{:test=>"kind_of? Numeric",
      :explanation=>
       "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
   :type=>:Float,
   :module=>:dist_fn}}
