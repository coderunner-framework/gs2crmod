{:diagnostics=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:print_line=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:print_line,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :print_flux_line=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:print_flux_line,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_linear=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_linear,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_nonlin=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_nonlin,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_omega=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_omega,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_omavg=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_omavg,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_ascii=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_ascii,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_kpar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_kpar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_gs=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_gs,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_g=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_g,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_gg=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_gg,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_vspace_slices=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_vspace_slices,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_hrate=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_hrate,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_elsasser=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_elsasser,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_density_velocity=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_density_velocity,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_epartot=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_epartot,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_final_fields=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_final_fields,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_final_epar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_final_epar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_final_moments=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_final_moments,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_avg_moments=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_avg_moments,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_Epolar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_Epolar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_Eshell=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_Eshell,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_nl_flux=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_nl_flux,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_full_moments_r=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_full_moments_r,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :nwrite=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nwrite,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nmovie=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nmovie,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nwrite2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nwrite2,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nsave=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nsave,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :navg=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:navg,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :omegatol=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:omegatol,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :omegatinst=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:omegatinst,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :igomega=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:igomega,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :write_lorentzian=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_lorentzian,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :exit_when_converged=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:exit_when_converged,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :make_movie=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:make_movie,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :save_for_restart=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:save_for_restart,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_adapt_hc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_adapt_hc,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_verr=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_verr,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_vspectrum=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_vspectrum,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_kspectrum=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_kspectrum,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_init=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_init,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_gkp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_gkp,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_hkv=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_hkv,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_ktrans=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_ktrans,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :use_qshell=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:use_qshell,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_ptrans=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_ptrans,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :get_wtrans=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:get_wtrans,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :get_etrans=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:get_etrans,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_phi_over_time=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_phi_over_time,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_apar_over_time=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_apar_over_time,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :write_bpar_over_time=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_bpar_over_time,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :equil_io=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:equilibrium_file=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:equilibrium_file,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String}}},
 :layouts_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:layout=>
      {:should_include=>"true",
       :description=>
        "'yxles', 'lxyes', 'lyxes', 'lexys' Determines the way the grids are laid out in memory.",
       :help=>
        "Determines the way the grids are laid out in memory. Rightmost is parallelised first. \n** Can be 'yxles', 'lxyes', 'lyxes', 'lexys' \n** Strongly affects performance on parallel computers\n** In general avoid parallelizing over x. For this reason 'lxyes' is often a good choice.",
       :tests=>["Tst::STRING"],
       :code_name=>:layout,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :allow_accel=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:allow_accel,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :memory=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:mem_account=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:mem_account,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :mem_output_on=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:mem_output_on,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :mem_debug=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:mem_debug,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :reinit_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:delt_adj=>
      {:should_include=>"true",
       :description=>"When the time step needs to be changed, it is adjusted ",
       :help=>"When the time step needs to be changed, it is adjusted ",
       :tests=>["Tst::FLOAT"],
       :code_name=>:delt_adj,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :delt_minimum=>
      {:should_include=>"true",
       :description=>"The minimum time step is delt_minimum.",
       :help=>"The minimum time step is delt_minimum.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:delt_minimum,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :abort_rapid_time_step_change=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:abort_rapid_time_step_change,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :driver=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:amplitude=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Amplitude of Langevin antenna.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:amplitude,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :w_antenna=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Frequency of Langevin antenna.\n",
       :tests=>["true"],
       :code_name=>:w_antenna,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :nk_stir=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Number of independent Fourier modes driven by antenna.\n",
       :tests=>["Tst::INT"],
       :code_name=>:nk_stir,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :write_antenna=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Write antenna amplitudes to ASCII file for debugging.\n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:write_antenna,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :ant_off=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Overrides all and turns off antenna if true.\n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:ant_off,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :w_dot=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:w_dot,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :t0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:t0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :restarting=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:restarting,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :stir=>
  {:description=>"",
   :should_include=>"true",
   :enumerator=>{:name=>:nk_stir, :estimated_value=>10},
   :variables=>
    {:stir_kx=>
      {:should_include=>"true",
       :description=>"Wavenumber of antennae",
       :help=>"Wavenumber of antennae.",
       :code_name=>:kx,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :stir_ky=>
      {:should_include=>"true",
       :description=>"Wavenumber of antennae",
       :help=>"Wavenumber of antennae",
       :code_name=>:ky,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :stir_kz=>
      {:should_include=>"true",
       :description=>"Wavenumber of antennae",
       :help=>"Wavenumber of antennae",
       :code_name=>:kz,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}},
   :enumerator=>{:name=>:nk_stir, :estimated_value=>10}},
 :collisions_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:collision_model=>
      {:should_include=>"true",
       :description=>
        "Collision model used in the simulation. Options: 'default', 'none', 'lorentz', 'ediffuse'",
       :help=>
        "Collision model used in the simulation. \n\n** ''default'' = pitch angle scattering and energy diffusion\n** ''collisionless'',''none'' = collisionless\n** ''lorentz'' =  pitch angle scattering only\n** ''ediffuse'' = energy diffusion only\n** ''krook'' = use home made krook operator (no reason to use this!)",
       :tests=>["Tst::STRING"],
       :code_name=>:collision_model,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :conserve_momentum=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Conserve parallel momentum.  Recommend F at this time.\n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:conserve_momentum,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :heating=>
      {:should_include=>"true",
       :description=>nil,
       :help=>"Set to .true. to compute collisional heating.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:heating,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :adjust=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:adjust,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :const_v=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:const_v,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :cfac=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        "Factor multiplying FLR terms in collision operator.  1.0 by default.  Set to 0.0 to turn off FLR corrections.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:cfac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :hypermult=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:hypermult,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :conserve_moments=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        "Set to .true. to guarantee collision operator conserves momentum and energy.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:conserve_moments,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :lorentz_scheme=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:lorentz_scheme,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :ediff_scheme=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:ediff_scheme,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :test=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:test,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :resistivity=>
      {:should_include=>"true",
       :description=>"",
       :help=>"",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:resistivity,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :resistivity_test=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:resistivity_test,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :ei_coll_only=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:ei_coll_only,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :conservative=>
      {:should_include=>"true",
       :description=>nil,
       :help=>"Set to .true. to guarantee exact conservation properties.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:conservative,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :dist_fn_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:poisfac=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " If non-zero, quasineutrality is not enforced; poisfac=  (lambda_Debye/rho)**2 \n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:poisfac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :adiabatic_option=>
      {:should_include=>"true",
       :description=>
        "The form of the adiabatic response (if a species is being modeled as adiabatic).",
       :help=>
        "The form of the adiabatic response (if a species is being modeled as adiabatic). Ignored if there are electrons in the species list.\n**  'no-field-line-average-term'  Adiabatic species has n = Phi.  Appropriate for single-species ETG simulations. \n**  'default'  Same as 'no-field-line-average-term'\n**  'iphi00=0' Same as 'no-field-line-average-term'\n**  'iphi00=1' Same as 'no-field-line-average-term'\n**  'field-line-average-term'  Adiabatic species has n=Phi-< Phi >.  Appropriate for single-species ITG simulations.\n**  'iphi00=2' Same as field-line-average-term'\n**  'iphi00=3' Adiabatic species has n=Phi-< Phi >_y.  Incorrect implementation of field-line-average-term.",
       :tests=>["Tst::STRING"],
       :code_name=>:adiabatic_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :mult_imp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " Allow different species to have different values of bakdif and fexpr.   Not allowed for nonlinear runs. \n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:mult_imp,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :test_df=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:test,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :def_parity=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" True only allows solutions of single parity.\n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:def_parity,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :even=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:even,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :g_exb=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:g_exb,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :test_bes=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:test_bes,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :g_pvg=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:g_pvg,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :exit_if_g_exb_fails=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:exit_if_g_exb_fails,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :g_exb_start_time=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:g_exb_start_time,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :g_exb_start_timestep=>
      {:should_include=>"true",
       :description=>
        "Perpendicular flow shear will not be applied until this timestep.",
       :help=>
        "Perpendicular flow shear will not be applied until this timestep. This does not affect parallel flow shear.",
       :tests=>["Tst::INT"],
       :code_name=>:g_exb_start_timestep,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :g_exb_error_limit=>
      {:should_include=>"true",
       :description=>"",
       :help=>
        "* If using the new flow shear implementation, specify the maximum relative error in phi2",
       :code_name=>:g_exb_error_limit,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float}}},
 :source_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:source_t0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:t0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :omega0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Frequency of non-standard source (if selected above). \n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:omega0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :gamma0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Growth rate of non-standard source (if selected above). \n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:gamma0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :source0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Amplitude of non-standard source (if selected above). \n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:source0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :phi_ext=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Amplitude of external Phi added as source term.\n",
       :tests=>["true"],
       :code_name=>:phi_ext,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :source_option=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " \n** 'source_option_full' Solve GK equation in standard form (with no artificial sources)\n** 'default' Same as 'source_option_full' \n** 'zero' The GK distribution function will be advanced non-self-consistently.\n** 'sine' The GK distribution function will be advanced non-self-consistently.\n** 'cosine'The GK distribution function will be advanced non-self-consistently.\n** 'test1' The GK distribution function will be advanced non-self-consistently.\n** 'phiext_full' Solve GK equation with additional source proportional to phi_ext*F_0.  \n** 'test2_full' Solve GK equation with additional developmental sources included.  Experts only.\n** 'convect_full' Solve GK equation with additional developmental sources included.  Experts only.\n** 'test1' The GK distribution function will be advanced non-self-consistently.\n",
       :tests=>["Tst::STRING"],
       :code_name=>:source_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :aky_star=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Ignored.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:aky_star,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :akx_star=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Ignored.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:akx_star,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :cvdrift=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:cvdrift,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :gbdrift=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:gbdrift,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :alfy=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:alfy,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float}}},
 :dist_fn_species_knobs=>
  {:description=>"",
   :should_include=>"true",
   :enumerator=>{:name=>:nspec, :estimated_value=>5},
   :variables=>
    {:fexp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:fexp,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :bakdif=>
      {:should_include=>"true",
       :description=>"Spatial implicitness parameter. Recommended value: 0.05",
       :help=>
        "Spatial implicitness parameter. Any value greater than 0 adds numerical dissipation (usually necessary).\n** Recommended value: 0.05",
       :tests=>["Tst::FLOAT"],
       :code_name=>:bakdif,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :bd_exp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:bd_exp,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}}},
 :hyper_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:hyper_option=>
      {:should_include=>"true",
       :description=>nil,
       :help=>"'default' is 'none'",
       :tests=>["Tst::STRING"],
       :code_name=>:hyper_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :const_amp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:const_amp,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :include_kpar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:include_kpar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :isotropic_shear=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:isotropic_shear,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :d_hyperres=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:D_hyperres,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :d_hypervisc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:D_hypervisc,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :d_hyper=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:D_hyper,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :omega_osc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:omega_osc,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :gridnorm=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:gridnorm,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :nexp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nexp,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}}},
 :init_g_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:ginit_option=>
      {:should_include=>"true",
       :description=>
        "Sets the way that the distribution function is initialized.",
       :help=>
        "Sets the way that the distribution function is initialized. There are many possible choices.\n**  'default'\n**  'noise'  This is the  recommended selection.  Pretty random.\n**  'test1'\n**  'xi'\n**  'xi2'\n**  'zero'\n**  'test3'\n**  'convect'\n**  'rh'\n**  'many'\n**  'small'\n**  'file'\n**  'cont'\n**  'kz0'  initialise only with k_parallel=0\n**  'nl'\n**  'nl2'\n**  'nl3'\n**  'nl4'\n**  'nl5'\n**  'nl6'\n**  'gs'\n**  'kpar'\n**  'zonal_only'  Restart but set all non-zonal components of the potential and the distribution function to 0. Noise can be added to these other components by setting iphiinit > 0.\n**  'single_parallel_mode'  Initialise only with a single parallel mode specified by either ikpar_init for periodic boundary conditions or kpar_init for linked boundary conditions. Intended for linear calculations.\n**  'all_modes_equal'  Initialise with every single parallel and perpendicular mode given the same amplitude. Intended for linear calculations.",
       :tests=>["Tst::STRING"],
       :code_name=>:ginit_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :phiinit=>
      {:should_include=>"true",
       :description=>
        "Average amplitude of initial perturbation of each Fourier mode.",
       :help=>
        "Average amplitude of initial perturbation of each Fourier mode.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:phiinit,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :k0=>
      {:should_include=>"true",
       :description=>"Advanced. Rarely used.",
       :help=>
        "Available for highly specialized initial conditions.  Do not use unless you know what you are doing. Rarely used.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:k0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :kw=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:kw,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :chop_side=>
      {:should_include=>"true",
       :description=>"Rarely needed. Forces asymmetry into initial condition.",
       :help=>"Rarely needed.  Forces asymmetry into initial condition.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:chop_side,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :restart_file=>
      {:should_include=>"true",
       :description=>"Base of filenames with restart data.",
       :help=>"Base of filenames with restart data.",
       :tests=>["Tst::STRING"],
       :code_name=>:restart_file,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :restart_dir=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:restart_dir,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :left=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Chop out left side in theta. \n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:left,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :ikk=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Used only for secondary/tertiary calculations.\n",
       :tests=>["Tst::INT"],
       :code_name=>:ikk,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :itt=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Used only for secondary/tertiary calculations.\n",
       :tests=>["Tst::INT"],
       :code_name=>:itt,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :scale=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Allows rescaling of amplitudes for restarts.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:scale,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tstart=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Force t=tstart at beginning of run.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tstart,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :zf_init=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " Amplitude of initial zonal flow perturbations relative to other modes\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:zf_init,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :den0=>
      {:should_include=>"true",
       :description=>"Parameters for setting up special initial conditions.",
       :help=>"Parameters for setting up special initial conditions.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:den0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :upar0=>
      {:should_include=>"true",
       :description=>"Parameters for setting up special initial conditions.",
       :help=>"Parameters for setting up special initial conditions.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:upar0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tpar0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>"  Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tpar0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tperp0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>"  Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tperp0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :imfac=>
      {:should_include=>"true",
       :description=>"Used in rare cases.",
       :help=>"Used in rare cases.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:imfac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :refac=>
      {:should_include=>"true",
       :description=>"Used in rare cases.",
       :help=>"Used in rare cases.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:refac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :even_df=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:even,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :den1=>
      {:should_include=>"true",
       :description=>"Parameters for setting up special initial conditions.",
       :help=>"Parameters for setting up special initial conditions.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:den1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :upar1=>
      {:should_include=>"true",
       :description=>"Parameters for setting up special initial conditions.",
       :help=>"Parameters for setting up special initial conditions.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:upar1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tpar1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tpar1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tperp1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tperp1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :den2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:den2,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :upar2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:upar2,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tpar2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tpar2,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tperp2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Parameters for setting up special initial conditions.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tperp2,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :dphiinit=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:dphiinit,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :apar0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:apar0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :ikkk=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ikkk,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ittt=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ittt,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :phiamp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["true"],
       :code_name=>:phiamp,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :aparamp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["true"],
       :code_name=>:aparamp,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :phiinit0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:phiinit0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :a0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:a0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :b0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:b0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :null_phi=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:null_phi,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :null_bpar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:null_bpar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :null_apar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:null_apar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :adj_spec=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:adj_spec,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :eq_type=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:eq_type,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :prof_width=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:prof_width,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :eq_mode_u=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:eq_mode_u,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :eq_mode_n=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:eq_mode_n,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nkxy_pt=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["true"],
       :code_name=>:nkxy_pt,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :ukxy_pt=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["true"],
       :code_name=>:ukxy_pt,
       :must_pass=>
        [{:test=>"kind_of? Complex",
          :explanation=>"This variable must be a complex number."}],
       :type=>:Complex},
     :nl_option=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:nl_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :ndigits=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ndigits,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :separate_em_in=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:separate_em_in,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :separate_em_out=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:separate_em_out,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :k1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:k1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :kw1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:kw1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :p1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:p1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :pw1=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:pw1,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :diag2bath=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:diag2bath,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :phiinit_rand=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:phiinit_rand,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :ikpar_init=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ikpar_init,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ikx_init=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ikx_init,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :iky_init=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:iky_init,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ikpar_init2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ikpar_init2,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ikx_init2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ikx_init2,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :iky_init2=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:iky_init2,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :force_single_kpar=>
      {:should_include=>"true",
       :description=>
        "At every timestep set all other kpars to zero except ikpar_init.",
       :help=>
        "If a run is initialised with only a single parallel wavenumber, set all other parallel amplitudes to zero at every timestep.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:force_single_kpar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :kgrids=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:grid_option=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:grid_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :akperp=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:akperp,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :x0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:x0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :y0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:y0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nx=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nx,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ny=>
      {:should_include=>"true",
       :description=>"Number of grid points in the y direction.",
       :help=>"Number of grid points in the y direction.",
       :tests=>["Tst::INT"],
       :code_name=>:ny,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nkpolar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nkpolar,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :aky_min=>
      {:should_include=>"true",
       :description=>"Sets the minimum ky in box mode (default is zero).",
       :help=>
        "Sets the minimum ky in box mode (default is zero).\n** <tt> aky(ik) = ky_min + (ik-1)/y0",
       :tests=>["Tst::FLOAT"],
       :code_name=>:aky_min,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float}}},
 :le_grids_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:ngauss=>
      {:should_include=>"true",
       :description=>
        "Number of untrapped pitch-angles moving in one direction along field line.",
       :help=>
        "Number of untrapped pitch-angles moving in one direction along field line.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:ngauss,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :negrid=>
      {:should_include=>"true",
       :description=>"Total number of energy grid points",
       :help=>"Total number of energy grid points",
       :tests=>["Tst::INT"],
       :code_name=>:negrid,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :ecut=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " If advanced_egrid=T: Maximum energy resolved\n** Otherwise: Break between discretizations of energy grid.\n",
       :tests=>["Tst::FLOAT"],
       :code_name=>:ecut,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :test_legrids=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:test,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :testfac=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:testfac,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nmax=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nmax,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :wgt_fac=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:wgt_fac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :vgrid=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:vgrid,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :vcut=>
      {:should_include=>"true",
       :description=>
        "No. of standard deviations from the standard Maxwellian beyond which the distribution function will be set to 0",
       :help=>
        "No. of standard deviations from the standard Maxwellian beyond which the distribution function will be set to 0",
       :tests=>["Tst::FLOAT"],
       :code_name=>:vcut,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nesub=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " Only used if advanced_egrid = F; sets number of energy grid points below ecut\n",
       :tests=>["Tst::INT"],
       :code_name=>:nesub,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nesuper=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        " Only used if advanced_egrid = F; sets number of energy grid points above ecut\n",
       :tests=>["Tst::INT"],
       :code_name=>:nesuper,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}}},
 :nonlinear_terms_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:nonlinear_mode=>
      {:should_include=>"true",
       :description=>"Include nonlinear terms? ('on','off')",
       :help=>
        "Should the nonlinear terms be calculated?\n \n** 'none', 'default', 'off':  Do not include nonlinear terms, i.e. run a linear calculation.\n** 'on' Include nonlinear terms.",
       :tests=>["Tst::STRING"],
       :code_name=>:nonlinear_mode,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :cfl=>
      {:should_include=>"true",
       :description=>"The maximum delt < cfl * min(Delta_perp/v_perp)",
       :help=>"The maximum delt < cfl * min(Delta_perp/v_perp)",
       :tests=>["Tst::FLOAT"],
       :code_name=>:cfl,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :zip=>
      {:should_include=>"true",
       :description=>nil,
       :help=>" Experts only (for secondary/tertiary calculations). \n",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:zip,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :parameters=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:beta=>
      {:should_include=>"true",
       :description=>
        "Ratio of particle to magnetic pressure (reference Beta, not total beta):  beta=n_0 T_0 /( B^2 / (8 pi))",
       :help=>
        "In general, <math>\\beta</math> is the ratio of kinetic to magnetic energy.  In GS2, the parameter <math>\\beta</math> affects only the dynamics, not the equilibrium.  \n**For electromagnetic runs, the contribution of each species to the total parallel current is weighted by a factor of <math>w_s = 2 \\beta Z_s n_s \\sqrt{T_s/m_s}</math>.\n**For electromagnetic runs that include <math>\\delta B_\\parallel</math>, this field is proportional to <math>\\beta</math>.\n**The contribution of <math>(\\delta B)^2</math> to the total gyrokinetic energy is inversely proportional to this input parameter.\n**If an antenna is set up to drive Alfven waves, then <math>\\beta</math> is used to calculate the Alfven frequency.  \n**For some collision operator models, <math>\\beta</math> is used to calculate the resistivity.  \n**For some rarely-used initial conditions, <math>\\beta</math> appears explicitly. \n**Important:  <math>\\beta</math> is <b>not</b> automatically set to be consistent with the value of <math>\\beta</math> used to calculate properties of a given magnetic equilibrium.  The user is responsible for choosing the gradients, densities, and temperatures of all species to be consistent with the values of <math>\\beta</math> and <math>\\beta'</math> which appear here and elsewhere.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:beta,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :zeff=>
      {:should_include=>"true",
       :description=>"Effective ionic charge.",
       :help=>
        "Effective ionic charge.  The parameter <math>Z_{\\rm eff}</math> appears only in the electron collision frequency, and is not automatically set to be consistent with the mix of species specified in the species namelists.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:zeff,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tite=>
      {:should_include=>"true",
       :description=>"Ratio of ion to electron temperatures.",
       :help=>
        "Ratio of ion to electron temperatures.  This parameter is used only when there is no species called \"electron\" included.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tite,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :aant=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:aant,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:delt=>
      {:should_include=>"true",
       :description=>"Time step",
       :help=>
        "Timestep, in units of <math>a/v_{t0}</math>.  For linear runs, this value does not change.  For nonlinear runs, the timestep used by the code will not be allowed to exceed this value.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:delt,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nstep=>
      {:should_include=>"true",
       :description=>"Maximum number of timesteps",
       :help=>
        "Number of timesteps that will be taken, unless the code stops for some (usually user-specified) reason.",
       :tests=>["Tst::INT"],
       :code_name=>:nstep,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :eqzip_option=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::STRING"],
       :code_name=>:eqzip_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :eqzip=>
      {:should_include=>"true",
       :description=>
        "True only for secondary/tertiary instability calculations.",
       :help=>
        "Default = .false.   Do not evolve certain <math>k</math> modes in time.  Set this to true only if you know what you are doing. True only for secondary/tertiary instability calculations.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:eqzip,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :secondary=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        "Default = .false.  Do not set to true unless you know what you are doing.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:secondary,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :tertiary=>
      {:should_include=>"true",
       :description=>nil,
       :help=>
        "Default = .false.  Do not set to true unless you know what you are doing.",
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:tertiary,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :kill_full_eq_evol=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:kill_full_eq_evol,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :avail_cpu_time=>
      {:should_include=>"true",
       :description=>
        "Specify the available wall clock time in seconds. GS2 will exit before this time.",
       :help=>
        "Specify the available wall clock time in seconds. GS2 will exit before this time. This ensures that all the output files are written correctly.  CodeRunner automatically sets this quantity unless it is given the value false.",
       :tests=>["Tst::FLOAT"],
       :code_name=>:avail_cpu_time,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :store_eq=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:store_eq,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :delt_option=>
      {:should_include=>"true",
       :description=>"Deprecated.",
       :help=>
        "Deprecated.  Do not use.  (Use 'check_restart' to get initial timestep from restart file, 'default' otherwise.)",
       :tests=>["Tst::STRING"],
       :code_name=>:delt_option,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
     :use_Phi=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:use_Phi,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :use_Apar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:use_Apar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :use_Bpar=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:use_Bpar,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool}}},
 :species_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:nspec=>
      {:should_include=>"true",
       :description=>"Number of kinetic species evolved.",
       :help=>"Number of kinetic species evolved.",
       :tests=>["Tst::INT"],
       :code_name=>:nspec,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}}},
 :species_parameters=>
  {:description=>"",
   :should_include=>"true",
   :enumerator=>{:name=>:nspec, :estimated_value=>5},
   :variables=>
    {:z=>
      {:should_include=>"true",
       :description=>"Charge",
       :help=>"Charge",
       :tests=>["Tst::FLOAT"],
       :code_name=>:z,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :mass=>
      {:should_include=>"true",
       :description=>"Mass",
       :help=>"Mass",
       :tests=>["Tst::FLOAT"],
       :code_name=>:mass,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :dens=>
      {:should_include=>"true",
       :description=>"Density\t",
       :help=>"Density\t",
       :tests=>["Tst::FLOAT"],
       :code_name=>:dens,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :dens0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:dens0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :u0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:u0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tpar0_species=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:tpar0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tperp0_species=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:tperp0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :temp=>
      {:should_include=>"true",
       :description=>"Temperature",
       :help=>"Temperature",
       :tests=>["Tst::FLOAT"],
       :code_name=>:temp,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :tprim=>
      {:should_include=>"true",
       :description=>"-1/T (dT/drho)",
       :help=>
        "Normalised inverse temperature gradient: <math>-1/T (dT/d\\rho)</math>",
       :tests=>["Tst::FLOAT"],
       :code_name=>:tprim,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :fprim=>
      {:should_include=>"true",
       :description=>"-1/n (dn/drho)",
       :help=>
        "Normalised inverse density gradient: <math>-1/n (dn/d\\rho)</math>",
       :tests=>["Tst::FLOAT"],
       :code_name=>:fprim,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :uprim=>
      {:should_include=>"true",
       :description=>"?",
       :help=>"?",
       :tests=>["Tst::FLOAT"],
       :code_name=>:uprim,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :type=>
      {:should_include=>"true",
       :description=>"Type of species, e.g. 'ion', 'electron', 'beam'",
       :help=>
        "Type of species:\n** 'ion' Thermal ion species\n** 'default' Same as 'ion'\n** 'electron' Thermal electron species\n** 'e' Same as 'electron'\n** 'beam' Slowing down distribution (Requires advanced_egrid = F)\n** 'slowing_down' Same as 'beam'\n** 'fast' Same as 'beam'\n** 'alpha' Same as 'beam'",
       :tests=>["Tst::INT"],
       :code_name=>:type,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:Integer},
     :nu=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nu,
       :must_pass=>
        [{:test=>"kind_of? Float or kind_of? Integer",
          :explanation=>"This variable must be a float (integers ok)."}],
       :type=>:Integer},
     :nu_h=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:nu_h,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nu_p=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:nu_p,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nexp_h=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:nexp_h,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :nexp_p=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:nexp_p,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :adapt_hc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:adapt_hc,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
     :kp_hc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:kp_hc,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :dkp_hc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:dkp_hc,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :gw_hc=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:gw_hc,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :gw_frac=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:gw_frac,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :min_nuh=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:min_nuh,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :max_nuh=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:max_nuh,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float}}},
 :parameters_knobs=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:force_5d=>
      {:should_include=>"true",
       :description=>"Force code to include Hankel space",
       :help=>nil,
       :tests=>["Tst::FORTRAN_BOOL"],
       :code_name=>:force_5d,
       :must_pass=>
        [{:test=>"kind_of? String and FORTRAN_BOOLS.include? self",
          :explanation=>
           "This variable must be a fortran boolean. (In Ruby this is represented as a string: e.g. '.true.')"}],
       :type=>:Fortran_Bool},
    :fourier_filter=>
      {:should_include=>"true",
       :description=>"Method of Fourier filtering: hou_li, two_thirds",
       :help=>
        "Method of Fourier filtering: hou_li, two_thirds",
       :tests=>["Tst::STRING"],
       :code_name=>:fourier_filter,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
    :suppress_kz=>
      {:should_include=>"true",
       :description=>"Method of suppressing low kz modes: none, zero, krook",
       :help=>
        "Method of suppressing low kz modes: none, zero, krook",
       :tests=>["Tst::STRING"],
       :code_name=>:suppress_kz,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String},
    :phi_method=>
      {:should_include=>"true",
       :description=>"Method of determining fields from the distribution in Hankel space",
       :help=>
        "Should the nonlinear terms be calculated?\n \n** 'none', 'default', 'off':  Do not include nonlinear terms, i.e. run a linear calculation.\n** 'on' Include nonlinear terms.",
       :tests=>["Tst::STRING"],
       :code_name=>:phi_method,
       :must_pass=>
        [{:test=>"kind_of? String",
          :explanation=>"This variable must be a string."}],
       :type=>:String}}},
 :theta_grid=>
  {:description=>"",
   :should_include=>"true",
   :variables=>
    {:z0=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::FLOAT"],
       :code_name=>:z0,
       :must_pass=>
        [{:test=>"kind_of? Numeric",
          :explanation=>
           "This variable must be a floating point number (an integer is also acceptable: it will be converted into a floating point number)."}],
       :type=>:Float},
     :ntheta=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:ntheta,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer},
     :nperiod=>
      {:should_include=>"true",
       :description=>nil,
       :help=>nil,
       :tests=>["Tst::INT"],
       :code_name=>:nperiod,
       :must_pass=>
        [{:test=>"kind_of? Integer",
          :explanation=>"This variable must be an integer."}],
       :type=>:Integer}}}}
